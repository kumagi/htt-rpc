require './ast_node'

grammar Kantera
  include Util
  rule all
    (comment {
       def build(s); end
     }
     / setting {
       def build(doc)
         doc.settings.merge!(parse)
       end
     } / package {
       def build(doc)
         doc.package = parse
       end
     } / option {
       def build(doc)
         doc.options.merge!(parse)
       end
     } / message {
       def build(doc)
         parse.dump(7)
         doc.messages << parse
       end
     } / service {
       def build(doc)
         doc.services << parse
       end
     } / "\n" {
       def build(s); end
     }
     )+ {
         def build(doc)
           elements.each{|n|
             n.build(doc)
           }
         end
       }
  end

  rule setting
    identifier space '=' space string space? ';' {
      def key; elements[0].text_value; end
      def value; elements[4].text_value; end
      def parse; {key => value}; end
    }
  end

  rule package
    'package' space identifier space? ';' {
      def name; elements[2].text_value; end
      def parse; name; end
    }
  end

  rule option
    'option' space identifier space? '=' space? string space? ';' {
      def key; elements[2].text_value; end
      def value; elements[6].text_value; end
      def parse; {key => value}; end
      true
    }
  end

  rule message
    'message' space identifier space? '{' (space? message_def)* space? '}' {
      def name; elements[2].text_value; end
      def parse
        mes = Message.new
        mes.name = name
        elements[5].elements.each{|e|
          child = e.elements[1]
          begin
            mes.add_element(child.parse)
          rescue
          end
        }

        mes
      end
    }
  end

  rule message_def
    member / enum / message
  end

  rule member
    member_atribute?
    identifier space identifier space '=' space number space? ';' {
      def name; elements[3].text_value; end
      def type; elements[1].text_value; end
      def node_id; elements[7].text_value.to_i; end
      def attr;
        return elements[0].attr unless elements[0].text_value.empty?
        nil
      end
      def parse
        Node.new(name, type, node_id, attr)
      end
    }
  end

  rule member_atribute
    ('optional' / 'required' / 'repeated') space {
      def attr; elements[0].text_value; end
    }
  end

  rule enum
    'enum' space identifier space '{' space
       (identifier space '=' space number space? ';' space)*
    '}' {
      def name; elements[2].text_value; end
      def parse
        nodes = elements[6].elements.map{|e|
          name = e.elements[0].text_value
          num = e.elements[4].text_value.to_i
          EnumNode.new(name, num)
        }
        Enum.new(name, nodes)
      end
    }
  end

  rule service
    'service' space identifier space? '{' (space? method_def)* space? '}' {
      def name; elements[2].text_value; end
      def parse
        s = Service.new
        s.name = name
        methods = elements[5].elements.map{|e|
          s.procedures << e.elements[1].parse
        }
        s
      end
    }
  end

  rule method_def
    ('stream' space)? verb space path argument_list space?
     '->' space? ('stream' space)? identifier space? ';' {
      def name
        method = elements[1].text_value.downcase
        path = elements[3].text_value.downcase.gsub(/\//, "_")
        method + path
      end
      def arguments; elements[4].parse; end
      def returns;
        elements[9].text_value; end
      def parse
        Procedure.new(name, arguments, returns, nil, nil)
      end
    }
  end

  rule verb
    'GET' / 'POST' / 'PUT' / 'PATCH' / 'DELETE'
  end

  rule argument_list
    '(' space? identifier space identifier
      (space? ',' space? identifier space identifier)* space? ')' {
      def parse
        first_type = elements[2].text_value
        first_name = elements[4].text_value
        rest = elements[5].elements.map{|m|
          type = m.elements[3].text_value
          name = m.elements[5].text_value
          a = Argument.new
          a.name = name
          a.type = type
          a
        }
        t = Argument.new

        t.name = first_name
        t.type = first_type
        [t] + rest
      end
    }
  end
end

