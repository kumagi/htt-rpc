require 'pp'
require './ast_node'

grammar Kantera
  include Util
  rule all
    (comment / setting / package /
      option / message / service / "\n")+ {
      def build(builder)
        elements
          .reject{|d| d.text_value == "\n"}
          .map{|d|
            begin
              d.build(builder)
            rescue => e
              p e
            end
          }
      end
    }
  end

  rule setting
    identifier space '=' space string space? ';' {
      def key; elements[0].text_value; end
      def value; elements[4].text_value; end
      def build(builder); builder.settings[key] = value; end
    }
  end

  rule package
    'package' space identifier space? ';' {
      def name; elements[0].text_value; end
      def build(builder); builder.package = name; end
    }
  end

  rule option
    'option' space identifier space? '=' space? string space? ';' {
      def key; elements[2].text_value; end
      def value; elements[6].text_value; end
      def build(builder); builder.options[key] = value; end
      true
    }
  end

  rule message
    'message' space identifier space? '{' (space? message_def)* space? '}' {
      def name; elements[2].text_value; end
      def build(doc)
        mes = Message.new(name)
        elements[5].elements.each_with_index{|e, i|
          e.elements[1].build(mes)
        }
        doc.messages[name] = mes
      end
    }
  end

  rule message_def
    member / enum / message {
      def build(mes)
        puts "defining[#{text_value}]"
        elements.each{|e|
          puts "do[#{e.text_value}]"
          e.build(mes)
          puts "ok[#{e.text_value}]"
        }
      end
    }
  end

  rule member
    member_atribute?
    identifier space identifier space '=' space number space? ';' {
      def name; elements[3].text_value; end
      def type; elements[1].text_value; end
      def node_id; elements[6].text_value.to_i; end
      def attr;
        return elements[0].attr unless elements[0].text_value.empty?
        nil
      end
      def build(mes)
        puts "build member [#{text_value}]"
        mes.nodes << Node.new(name, type, node_id, attr)
        puts "build member [#{text_value}]"
      end
    }
  end

  rule member_atribute
    ('optional' / 'required' / 'repeated') space {
      def attr; elements[0].text_value; end
    }
  end

  rule enum
    'enum' space identifier space '{' space
       (identifier space '=' space number space? ';' space)*
    '}' {
      def name; elements[2].text_value; end
      def build(mes)
        nodes = elements[6].elements.map{|e|
          name = e.elements[0].text_value
          num = e.elements[5].text_value.to_i
          EnumNode.new(name, num)
        }
        mes.enums[name] = Enum.new(name, nodes)
      end
    }
  end

  rule service
    'service' space identifier space? '{' (space? method_def)* space? '}' {
      def name; elements[2].text_value; end
      def build(doc)
        methods = elements[5].elements.map{|e|
          e.build(doc)
        }
      end
    }
  end

  rule method_def
    ('stream' space)? verb space path argument_list space? '->' space? ('stream' space)? identifier space? ';' {
      def name
        method = elements[1].text_value.downcase
        path = elements[3].text_value.downcase.gsub(/\//, "_")
        method + path
      end
      def arguments; elements[4].arguments; end
      def returns; elements[9].elements[1].text_value; end
      def method
        Procedure.new(name, arguments, returns, nil, nil)
      end
    }
  end

  rule verb
    'GET' / 'POST' / 'PUT' / 'PATCH' / 'DELETE'
  end

  rule argument_list
    '(' space? identifier space identifier
      (space? ',' space? identifier space identifier)* space? ')' {
      def arguments
        first_type = elements[2].text_value
        first_name = elements[4].text_value
        rest = elements[5].elements.map{|m|
          type = m.elements[3].text_value
          name = m.elements[5].text_value
          Argument.new(type, name)
        }
        [Argument.new(first_type, first_name)] + rest
      end
    }
  end

end
